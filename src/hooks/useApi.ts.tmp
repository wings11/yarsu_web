import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { apiService } from '@/lib/api'
import { supabase } from '@/lib/supabase'

// Chat hooks
export function useChats() {
  return useQuery({
    queryKey: ['chats'],
    queryFn: async () => {
      try {
        const data = await apiService.getChats()
        return data
      } catch (error) {
        throw error
      }
    },
    retry: 1,
    staleTime: 0,
    gcTime: 0,
  })
}

// Enhanced chats hook with real user emails from Supabase users table
export function useChatsWithUsers() {
  return useQuery({
    queryKey: ['chats-with-users'],
    queryFn: async () => {
      try {
        // Get all chats from backend
        const chats = await apiService.getChats()
        
        if (!chats || chats.length === 0) {
          return []
        }

        // Extract unique user IDs from chats
        const userIds = Array.from(new Set(chats.map((chat: any) => chat.user_id)))
        
        // Get real user data from Supabase users table (RLS disabled)
        const { data: users, error } = await supabase
          .from('users')
          .select('id, email, role')
          .in('id', userIds)
        
        if (error) {
          throw error
        }
        
        // Create a user lookup map
        const userMap = new Map()
        users?.forEach((user: any) => {
          userMap.set(user.id, {
            id: user.id,
            email: user.email,
            role: user.role
          })
        })
        
        // Enhance chats with real user data
        const chatsWithUsers = chats.map((chat: any) => ({
          ...chat,
          user: userMap.get(chat.user_id) || { 
            id: chat.user_id,
            email: `unknown-user-${chat.user_id.slice(-8)}@yarsu.app` // Fallback for missing users
          }
        }))
        
        
        return chatsWithUsers
      } catch (error) {
        console.error('useChatsWithUsers: API call failed:', error)
        throw error
      }
    },
    retry: 1,
    staleTime: 5 * 60 * 1000, // Cache for 5 minutes since user data doesn't change often
  })
}

export function useMessages(chatId: number) {
  return useQuery({
    queryKey: ['messages', chatId],
    queryFn: () => apiService.getMessages(chatId),
    enabled: !!chatId,
  })
}

export function useSendMessage() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: ({ message, chatId, type }: { message: string, chatId?: number, type?: string }) => {
      
      return apiService.sendMessage(message, chatId, type)
    },
    onSuccess: (data: any, { chatId }: any) => {
      
      if (chatId) {
        queryClient.invalidateQueries({ queryKey: ['messages', chatId] })
      }
      queryClient.invalidateQueries({ queryKey: ['chats'] })
    },
    onError: (error: any) => {
      console.error('useSendMessage: Failed to send message', error)
    }
  })
}

export function useReplyMessage() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: ({ message, chatId, type }: { message: string, chatId: number, type?: string }) =>
      apiService.replyMessage(message, chatId, type),
    onSuccess: (_: any, { chatId }: any) => {
      queryClient.invalidateQueries({ queryKey: ['messages', chatId] })
      queryClient.invalidateQueries({ queryKey: ['chats'] })
    },
    onError: () => {
      console.error('Failed to send reply')
    }
  })
}

// Content hooks
export function useRestaurants() {
  return useQuery({
    queryKey: ['restaurants'],
    queryFn: async () => {
      
      try {
        const data = await apiService.getRestaurants()
        
        return data
      } catch (error) {
        console.error('useRestaurants: API call failed:', error)
        throw error
      }
    },
    retry: 1,
    staleTime: 0,
    gcTime: 0,
  })
}

export function useHotels() {
  return useQuery({
    queryKey: ['hotels'],
    queryFn: async () => {
      
      try {
        const data = await apiService.getHotels()
        
        return data
      } catch (error) {
        console.error('useHotels: API call failed:', error)
        throw error
      }
    },
    retry: 1,
    staleTime: 0, // Always refetch
    gcTime: 0, // Don't cache (renamed from cacheTime in v5)
  })
}

export function useJobs() {
  return useQuery({
    queryKey: ['jobs'],
    queryFn: async () => {
      
      try {
        const data = await apiService.getJobs()
        
        return data
      } catch (error) {
        console.error('useJobs: API call failed:', error)
        throw error
      }
    },
    retry: 1,
    staleTime: 0,
    gcTime: 0,
  })
}

export function useCourses() {
  return useQuery({
    queryKey: ['courses'],
    queryFn: async () => {
      
      try {
        const data = await apiService.getCourses()
        
        return data
      } catch (error) {
        console.error('useCourses: API call failed:', error)
        throw error
      }
    },
    retry: 1,
    staleTime: 0,
    gcTime: 0,
  })
}

export function useCondos() {
  return useQuery({
    queryKey: ['condos'],
    queryFn: async () => {
      
      try {
        const data = await apiService.getCondos()
        
        return data
      } catch (error) {
        console.error('useCondos: API call failed:', error)
        throw error
      }
    },
    retry: 1,
    staleTime: 0,
    gcTime: 0,
  })
}

export function useTravelPosts() {
  return useQuery({
    queryKey: ['travel-posts'],
    queryFn: async () => {
      
      try {
        const data = await apiService.getTravelPosts()
        
        return data
      } catch (error) {
        console.error('useTravelPosts: API call failed:', error)
        throw error
      }
    },
    retry: 1,
    staleTime: 0,
    gcTime: 0,
  })
}

export function useGeneralPosts() {
  return useQuery({
    queryKey: ['general-posts'],
    queryFn: async () => {
      
      try {
        const data = await apiService.getGeneralPosts()
        
        return data
      } catch (error) {
        console.error('useGeneralPosts: API call failed:', error)
        throw error
      }
    },
    retry: 1,
    staleTime: 0,
    gcTime: 0,
  })
}

export function useDocs() {
  return useQuery({
    queryKey: ['docs'],
    queryFn: async () => {
      
      try {
        const data = await apiService.getDocs()
        
        return data
      } catch (error) {
        console.error('useDocs: API call failed:', error)
        throw error
      }
    },
    retry: 1,
    staleTime: 0,
    gcTime: 0,
  })
}

export function useLinks() {
  return useQuery({
    queryKey: ['links'],
    queryFn: async () => {
      
      try {
        const data = await apiService.getLinks()
        
        return data
      } catch (error) {
        console.error('useLinks: API call failed:', error)
        throw error
      }
    },
    retry: 1,
    staleTime: 0,
    gcTime: 0,
  })
}

export function useHighlights() {
  return useQuery({
    queryKey: ['highlights'],
    queryFn: async () => {
      
      try {
        const data = await apiService.getHighlights()
        
        return data
      } catch (error) {
        console.error('useHighlights: API call failed:', error)
        throw error
      }
    },
    retry: 1,
    staleTime: 0,
    gcTime: 0,
  })
}

// Job inquiry hook
export function useSubmitJobInquiry() {
  return useMutation({
    mutationFn: ({ jobId, inquiryData }: { jobId: number, inquiryData: any }) =>
      apiService.submitJobInquiry(jobId, inquiryData),
    onSuccess: () => {
      
    },
    onError: () => {
      console.error('Failed to submit job inquiry')
    }
  })
}
